package org.example.mycalendarbackend.service

import jakarta.annotation.PostConstruct
import net.fortuna.ical4j.data.CalendarBuilder
import net.fortuna.ical4j.model.ContentCollection
import net.fortuna.ical4j.model.component.VEvent
import net.fortuna.ical4j.model.property.*
import net.fortuna.ical4j.util.MapTimeZoneCache
import org.example.mycalendarbackend.domain.entity.CalendarEvent
import org.example.mycalendarbackend.domain.enums.Frequency
import org.springframework.stereotype.Service
import org.springframework.web.multipart.MultipartFile
import java.io.File
import java.io.StringReader
import java.nio.file.Files
import java.time.OffsetDateTime
import java.time.ZoneId
import java.time.ZonedDateTime
import kotlin.io.path.Path
import kotlin.jvm.optionals.getOrNull

@Service
class CalendarParser {

//    fun parseIcsContent(icsFile: MultipartFile): List<CalendarEvent> {
//        //System.setProperty("net.fortuna.ical4j.timezone.cache.impl", MapTimeZoneCache::class.java.name)
//        val builder = CalendarBuilder()
//        val calendar = builder.build(icsFile.inputStream) // TODO: maybe handle exceptions
//        val iCalEvents = calendar.getComponents<VEvent>("VEVENT")
//        return listOf()
//    }

    @PostConstruct
    fun test() {
        val path = Path("C:\\Users\\OLIVER-PC\\Desktop\\o.nikolovski1@gmail.com.ics")
        val content = Files.readString(path)
        parseIcsContent(content)
    }

    fun parseIcsContent(icsContent: String): List<CalendarEvent> {
        //System.setProperty("net.fortuna.ical4j.timezone.cache.impl", MapTimeZoneCache::class.java.name)
        val builder = CalendarBuilder()
        val calendar = builder.build(StringReader(icsContent)) // TODO: maybe handle exceptions
        val xWrTimezone = calendar.getProperty<XProperty>("X-WR-TIMEZONE").getOrNull()?.value
        val iCalEvents = calendar.getComponents<VEvent>("VEVENT")
        return iCalEvents.map { it.toCalendarEvent(xWrTimezone) }
    }

}

fun VEvent.toCalendarEvent(xWrTimezone: String? = null): CalendarEvent {
    val dtStartProperty = getProperty<DtStart<ZonedDateTime>>("DTSTART").get()
    val tzId = dtStartProperty.getParameters("TZID")?.firstOrNull()?.value
    val title = summary.getOrNull()?.value
    val description = description.getOrNull()?.value
    val zoneId = ZoneId.of(xWrTimezone ?: tzId)
    val startDate = dtStartProperty.date.withZoneSameInstant(zoneId)
    val endDate = getProperty<DtEnd<ZonedDateTime>>("DTEND").getOrNull()?.date?.withZoneSameInstant(zoneId)
    val duration = getProperty<Duration>("DURATION").getOrNull()?.duration
    val sequenceId = getProperty<Uid>("Uid").getOrNull()?.value ?: "" // TODO: generate custom sequence if uid is null
    val createdAt = getProperty<Created>("CREATED").getOrNull()?.date?.atZone(zoneId)
    val modifiedAt = getProperty<LastModified>("LAST-MODIFIED").getOrNull()?.date?.atZone(zoneId)
    val recur = getProperty<RRule<OffsetDateTime>>("RRULE").getOrNull()?.recur
    val interval = recur?.interval
    val frequency = Frequency.valueOf(recur?.frequency!!.name)
    val count = recur?.count
    val until = recur?.until // zavrshuva na kraj na den (sekunda pred polnok, vo UTC zona - Z)
    val weekDays = recur?.weekNoList
    val setPos = recur?.setPosList?.firstOrNull() // should have been list of integers instead
    val rruleString = recur.toString() // this can also be generated by my app instead
    val rruleText = null
    val recurrenceId = this.getProperty<RecurrenceId<ZonedDateTime>>("RECURRENCE-ID").getOrNull()?.date
        ?.withZoneSameInstant(zoneId)
    return TODO()
}